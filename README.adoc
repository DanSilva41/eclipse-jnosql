= Eclipse JNoSQL
:toc: auto

Jakarta NoSQL is a Java framework that streamlines the integration of Java applications with NoSQL databases.

== One Mapping API to multiples NoSQL databases

Eclipse JNoSQL has one API for each NoSQL database type. However, it uses the same annotations to map Java objects. Therefore, with just these annotations that look like JPA, there is support for more than twenty NoSQL databases.

[source,java]
----
@Entity
public class Car {

    @Id
    private Long id;
    @Column
    private String name;
    @Column
    private CarType type;
 //...
}

----

The Mapper annotations are pretty familiar if you are a JPA developer:

* Entity
* Id
* Column
* Embeddable
* Convert
* DiscriminatorColumn
* DiscriminatorValue
* Inheritance
* MappedSuperclass

IMPORTANT: Although similar to JPA, Jakarta NoSQL defines persistable fields with either ID or Column annotation.

After mapping an entity, you can explore the advantage of a Template, which is a helper to increase productivity on NoSQL operations.

[source,java]
----
@Inject
Template template;
...

Car ferrari = Car.id(1L).name("Ferrari").type(CarType.SPORT);
template.insert(ferrari);

Optional<Car> car = template.find(Car.class, 1L);
template.delete(Car.class, 1L);
----

This template has specialization to take the benefits of a particular NoSQL database type.

There is  ```Repository``` exploring the DDD pattern to have a higher abstraction.

[source,java]
----
public interface CarRepository extends Repository<Car, String> {

    Optional<Car> findByName(String name);

}

@Inject
CarRepository repository;
...

Car ferrari = Car.id(1L).name("Ferrari").type(CarType.SPORT);
repository.save(ferrari);
Optional<Car> idResult = repository.findById(1L);
Optional<Car> nameResult = repository.findByName("Ferrari");
----

== Getting started

Eclipse JNoSQL is an implementation of Jakarta NoSQL; it requires the minimum requirements:

* Java 11 (or higher)
* https://jakarta.ee/specifications/cdi/2.0/[CDI]
* https://jakarta.ee/specifications/jsonb/1.0/[JSON-B]
* https://jakarta.ee/specifications/jsonp/1.1/[JSON-P]
* https://microprofile.io/microprofile-config/[Eclipse Microprofile Configuration]

=== Key-value

Jakarta NoSQL has a key-value template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>mapping-key-value</artifactId>
    <version>1.0.0-b4</version>
</dependency>
----

Furthermore, check a key-value communication driver.
You can see some implementations in the https://github.com/eclipse/jnosql-communication-driver[JNoSQL communication-driver project].

[source,java]
----
@Inject
KeyValueTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.put(ferrari);
Optional<Car> car = template.get(1L, Car.class);
template.delete(1L);
----

It is a key-value agnostic database; thus, you can change the database without or less code impact possible.

=== Column

Jakarta NoSQL has a column template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>mapping-column</artifactId>
    <version>1.0.0-b4</version>
</dependency>
----

Furthermore, check a column communication driver.
You can see some implementations in the https://github.com/eclipse/jnosql-communication-driver[JNoSQL communication-driver project].

[source,java]
----
@Inject
ColumnTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);

ColumnDeleteQuery deleteQuery = delete().from("Car")
                    .where("_id").eq(1L).build();
template.delete(deleteQuery);


ColumnDeleteQuery query = select().from("Car")
                    .where("_id").eq(1L).build();

Optional<Car> result = template.singleResult("select * from Car where _id = 1");

----

It is a wide-column agnostic database; thus, you can change the database without or less code impact possible.

=== Document

Jakarta NoSQL has a document template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>mapping-document</artifactId>
    <version>1.0.0-b4</version>
</dependency>
----

Furthermore, check a document communication driver.
You can see some implementations in the https://github.com/eclipse/jnosql-communication-driver[JNoSQL communication-driver project].

[source,java]
----
@Inject
DocumentTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);

DocumentDeleteQuery deleteQuery = delete().from("Car")
                    .where("_id").eq(1L).build();
template.delete(deleteQuery);


DocumentDeleteQuery query = select().from("Car")
                    .where("_id").eq(1L).build();

Optional<Car> result = template.singleResult("select * from Car where _id = 1");

----

It is a document agnostic database; thus, you can change the database without or less code impact possible.

=== Graph

Jakarta NoSQL has a Graph template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>mapping-graph</artifactId>
    <version>1.0.0-b4</version>
</dependency>
----

Despite other Jakarta NoSQL types, Graph has no communication layer from Jakarta NoSQL API. It integrates with https://tinkerpop.apache.org/[Apache Tinkerpop] instead.

[source,java]
----
@Inject
GraphTemplate template;
...

Category java = Category.of("Java");
Book effectiveJava = Book.of("Effective Java");

template.insert(java);
template.insert(effectiveJava);
EdgeEntity edge = template.edge(java, "is", software);

Stream<Book> books = template.getTraversalVertex().hasLabel("Category").has("name", "Java").in("is").hasLabel("Book").getResult();
----

It is Apache TinkerPop agnostic database; thus, you can change the database without or less code impact possible.


=== Bean Validation

Eclipse JNoSQL has support for Bean Validation. It will validate before inserting/updating and constructing an entity.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>mapping-validation</artifactId>
    <version>1.0.0-b4</version>
</dependency>
----

It requires a https://jakarta.ee/specifications/bean-validation/[bean validation implementation].

[source,java]
----
@Entity
public class Car {

    @Column
    @NotNull
    @Pattern(regexp = "[A-Z]{3}-[0-9]{4}", message = "Invalid car plate")
    private String plate;

    @Column
    @NotNull
    @MonetaryMin(value = "100", message = "There is not car cheap like that")
    @MonetaryMax(value = "1000000", message = "The parking does not support fancy car")
    @CurrencyAccepted(currencies = "USD", message = "The car price must work with USD")
    @Convert(MonetaryAmountConverter.class)
    private MonetaryAmount price;

    @Column
    @NotBlank
    private String model;

    @Column
    @NotBlank
    private String color;
    ...
}
----


[source,java]
----
@Inject
Template template;
...
template.insert(new Car());//invalid car
----

=== More information

Check the https://www.jnosql.org/spec/[reference documentation], and https://www.jnosql.org/javadoc/[Javadocs] to know more.


== Code of Conduct

This project is governed by the Eclipse Foundation of Conduct. By participating, you are expected to uphold this code of conduct. Please report unacceptable behavior to codeofconduct@eclipse.org.


== Getting Help

Having trouble with Eclipse JNoSQL? We’d love to help!

Report bugs with Eclipse JNoSQL at https://github.com/eclipse/jnosql.

== Building from Source

You don’t need to build from source to use the project, but if you want to try, you can make it using Maven and Java 11 or higher.

[source, Bash]
----
mvn clean install
----